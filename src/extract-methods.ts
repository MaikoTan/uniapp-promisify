/**
 * This script generates `src/p-uni.ts` from types declared in `src/filters.ts`.
 *
 * What it does:
 * - Loads the TypeScript project via ts-morph (using tsconfig.json).
 * - Reads the `PromisifiableFunctionNames` type alias (a union of string literal names)
 *   to determine which Uni API functions should be wrapped with `promisify`.
 * - Reads the `Uni` type alias to iterate all API properties (methods).
 * - For each property, preserves its JSDoc and either:
 *   - exports `promisify(uni.prop)` when the property name is included in
 *     PromisifiableFunctionNames, or
 *   - exports `uni.prop` directly when it is not promisifiable.
 * - Formats the generated file with Prettier and writes it to `src/p-uni.ts`.
 */

import { outputFile } from 'fs-extra'
import { format } from 'prettier'
import { Project, SyntaxKind } from 'ts-morph'

/**
 * A record of method names to override with custom implementations.
 * This can be used to handle special cases where the default promisification
 * logic does not apply correctly.
 */
const methodOverrides: Record<string, string> = {
  addInterceptor: `export const addInterceptor = (name: string, options: UniApp.InterceptorOptions) => {
    return new Promise<any>((resolve, reject) => uni.addInterceptor(name, {
      ...options,
      success: (res) => resolve(res),
      fail: (err) => reject(err),
    }))
  }`,
}

const project = new Project({
  tsConfigFilePath: 'tsconfig.json',
})

const filtersSourceFile = project.getSourceFileOrThrow('src/filters.ts')
const typeChecker = project.getTypeChecker()

const uniTypeAlias = filtersSourceFile.getTypeAliasOrThrow('Uni')
const uniType = typeChecker.getTypeAtLocation(uniTypeAlias.getNameNode())!
const uniProperties = uniType.getProperties()

const outputLines: string[] = [
  '// This file is auto generated by `uniapp-promisify`. Do not edit it manually.',
  '',
  "import { promisify } from './index'",
]

uniProperties.forEach((property) => {
  const propName = property.getName()

  const valueDecls = property.getDeclarations()
  const methodSignatures = valueDecls.map((decl) => decl.asKindOrThrow(SyntaxKind.MethodSignature))

  // Preserve JSDoc for the property/method
  methodSignatures.forEach((methodSignature) => {
    methodSignature.getJsDocs().forEach((doc) => {
      outputLines.push(doc.getText().trim())
    })
  })

  const isCallbackLike = (() => {
    let res = false
    methodSignatures.forEach((sig) => {
      const optType = sig.getParameters()?.[0]?.getType()
      if (optType?.isObject()) {
        const props = optType.getProperties().map((p) => p.getName())
        if (props.includes('success') || props.includes('fail') || props.includes('complete')) {
          res = true
        }
      }
    })
    return res
  })()

  if (methodOverrides[propName]) {
    outputLines.push(methodOverrides[propName])
    outputLines.push('')
  } else if (isCallbackLike) {
    // check if the method has multiple parameters
    const hasMultiParameters = methodSignatures.some((methodSignature) => {
      return methodSignature.getParameters()?.length > 1
    })
    if (hasMultiParameters) {
      const mostParamsSignature = methodSignatures.reduce((prev, curr) => {
        return prev.getParameters().length > curr.getParameters().length ? prev : curr
      })
      const firstParam = mostParamsSignature.getParameters()[0].getType().getText()
      const restParams = mostParamsSignature
        .getParameters()
        .slice(1)
        .map((param) => `${param.getName()}${param.isOptional() ? '?' : ''}: ${param.getType().getText()}`)
      outputLines.push(`export const ${propName} = promisify<${firstParam}, [${restParams.join(', ')}]>(uni.${propName})`)
    } else {
      outputLines.push(`export const ${propName} = promisify(uni.${propName})`)
    }
  } else {
    outputLines.push(`export const ${propName} = uni.${propName}`)
  }
  outputLines.push('')
})

format(outputLines.join('\n'), {
  parser: 'typescript',
  singleQuote: true,
  trailingComma: 'all',
  semi: false,
  useTabs: false,
  tabWidth: 2,
  printWidth: 1000, // avoid line breaks
}).then((formatted) => {
  const path = 'src/p-uni.ts'
  outputFile(path, formatted)
})
